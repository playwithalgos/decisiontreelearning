<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.0/dist/svg.min.js"></script>

    <style>
        .dataset {
            width: 256px;
            margin: 4px;
            border: 1px solid gray;
            padding: 4px;
            border-radius: 16px;
        }

        .datasetchildren {
            display: grid;
            margin-left: 16px;

            padding-left: 16px;

        }

        .datasetchildren:not(:empty) {
            border-left: 2px solid black;
        }

        .currentAttribute {
            font-weight: bold;
            border: 2px solid black;

        }



        .datasetnode {
            display: inline-flex;
            margin-bottom: 2px;
        }


        .info {
            font-size: x-small;
        }
    </style>

</head>

<body>
    <h1>Decision tree learning</h1>

    <script>
        const dataset = [];
        const attributes = ["dark", "spotted", "big", "thin", "radioactive"];

        function randomBoolean() {
            return Math.round(Math.random());
        }

        for (let i = 0; i < 12; i++) {
            const mushroom = {
                dark: randomBoolean(),
                spotted: randomBoolean(),
                big: randomBoolean(),
                thin: randomBoolean(),
                radioactive: randomBoolean(),
                class: Math.round(Math.random())
            };

            if (dataset.map(JSON.stringify).indexOf(JSON.stringify({ ...mushroom, class: 1 - mushroom.class })) == -1)
                dataset.push(mushroom);
        }

        function createMushRoomElement(mushroom) {
            const draw = SVG().addTo('#dataset').size(32, 64);
            const colorHead = mushroom.dark ? '#885555' : '#ccaaaa'
            draw.circle(16).move(8, 22).fill('bbbbbb').stroke("black");
            const head = draw.circle(30).move(0, 1).fill(colorHead).stroke("black");

            if (mushroom.radioactive)
                head
                    .animate({
                        duration: 1000,
                        delay: 0,
                        when: 'now',
                        swing: true,
                        times: 5,
                        wait: 0
                    }).attr({ fill: mushroom.dark ? '#55aa55' : '#ccffaa' }).persist();

            if (mushroom.spotted) {
                draw.circle(8).move(16, 16).fill('orange').stroke("black");
                draw.circle(8).move(10, 4).fill('orange').stroke("black");
                draw.circle(8).move(5, 17).fill('orange').stroke("black");
            }
            if (mushroom.thin)
                draw.scale(0.6, 1);
            if (!mushroom.big)
                draw.scale(0.7);

            if (mushroom.class) {
                draw.polyline([[16, 16], [24, 24], [32, 12]]).move(8, 40).stroke({ color: "green", width: 5 }).fill("none")
            }
            else {
                draw.polyline([[0, 0], [16, 16], [8, 8], [16, 0], [0, 16]]).move(8, 40).stroke({ color: "red", width: 5 }).fill("none")
            }

        }


        function createElementDataset(dataset) {
            const eldataset = document.createElement("div");
            eldataset.classList.add("dataset");
            eldataset.id = "dataset";
            document.body.appendChild(eldataset); // for SVG.js
            for (const mushroom of dataset)
                createMushRoomElement(mushroom);
            eldataset.id = null;
            return eldataset;
        }


        function isPure(dataset) {
            const dataset1 = dataset.filter((m) => m.class);
            return dataset1.length == 0 || dataset1.length == dataset.length
        }

        function createElementDatasetNode(dataset) {
            const el = document.createElement("div");
            el.classList.add("datasetnode");

            const eldataset = createElementDataset(dataset);
            const eldatasetAndButton = document.createElement("div");

            const elChildren = document.createElement("div");
            elChildren.classList.add("datasetchildren")

            const elButtons = document.createElement("div")
            if (!isPure(dataset))
                for (const a of attributes) {
                    const gini = GiniImpurity(dataset, a);
                    const entropy = EntropyImpurity(dataset, a);

                    if (!isNaN(gini)) {
                        const button = document.createElement("button");

                        button.innerHTML = a +
                            "<br/><span class='info'>gini: " + gini.toFixed(2) + "</span>" +
                            "<br/><span class='info'>entropy: " + entropy.toFixed(2) + "</span>";
                        elButtons.appendChild(button);
                        button.onclick = () => {
                            elChildren.innerHTML = "";
                            const ell = document.createElement("div");
                            ell.innerHTML = a;
                            elChildren.appendChild(ell);
                            elChildren.appendChild(createElementDatasetNode(dataset.filter((m) => m[a])));

                            const ell2 = document.createElement("div");
                            ell2.innerHTML = "not " + a;
                            elChildren.appendChild(ell2);
                            elChildren.appendChild(createElementDatasetNode(dataset.filter((m) => !m[a])));
                            for (const c of elButtons.children)
                                c.classList.remove("currentAttribute");
                            button.classList.add("currentAttribute");

                        }
                    }

                }




            eldatasetAndButton.appendChild(eldataset);
            eldatasetAndButton.appendChild(elButtons);
            el.appendChild(eldatasetAndButton);
            el.appendChild(elChildren);

            document.body.appendChild(el);

            return el;

        }

        createElementDatasetNode(dataset);

        function GiniImpurity(dataset, attribute) {
            const dataset0 = dataset.filter((m) => !m[attribute]);
            const dataset1 = dataset.filter((m) => m[attribute]);

            const PXa0 = dataset0.length;
            const PXa1 = dataset1.length;
            const PY0Xa0 = dataset0.filter((m) => 1 - m.class).length / dataset0.length;
            const PY1Xa0 = dataset0.filter((m) => m.class).length / dataset0.length;
            const PY0Xa1 = dataset1.filter((m) => 1 - m.class).length / dataset1.length;
            const PY1Xa1 = dataset1.filter((m) => m.class).length / dataset1.length;

            function c(x) {
                return x * (1 - x);
            }
            return PXa0 * (c(PY0Xa0) + c(PY1Xa0)) + PXa1 * (c(PY0Xa1) + c(PY1Xa1));
        }

        function EntropyImpurity(dataset, attribute) {
            const dataset0 = dataset.filter((m) => !m[attribute]);
            const dataset1 = dataset.filter((m) => m[attribute]);

            const PXa0 = dataset0.length;
            const PXa1 = dataset1.length;
            const PY0Xa0 = dataset0.filter((m) => 1 - m.class).length / dataset0.length;
            const PY1Xa0 = dataset0.filter((m) => m.class).length / dataset0.length;
            const PY0Xa1 = dataset1.filter((m) => 1 - m.class).length / dataset1.length;
            const PY1Xa1 = dataset1.filter((m) => m.class).length / dataset1.length;

       
            function log2Corrected(x) {
                if (x <= 0)
                    return 0;
                else return Math.log2(x);
            }
            return -(PY0Xa0 * log2Corrected(PY0Xa0 / PXa0)
                + PY1Xa0 * log2Corrected(PY1Xa0 / PXa0)
                + PY0Xa1 *log2Corrected(PY0Xa0 / PXa1)
                + PY1Xa1 * log2Corrected(PY1Xa1 / PXa1));


        }

    </script>
</body>